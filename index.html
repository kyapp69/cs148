<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Rendering &quot;Portal&quot; by torinmr</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/torinmr/cs148">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/torinmr/cs148/zipball/master">ZIP</a></li>
          <li class="downloads"><a href="https://github.com/torinmr/cs148/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>Rendering &quot;Portal&quot;</h1>
          <p>CS 148 Final Project</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/torinmr">torinmr</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <p>You can see a video version of this report with a live demo <a href="https://www.youtube.com/watch?v=C2PqlxjEwy4">here!</a> Also, click View On GitHub above to see my source code.</p>

<h1>
<a id="problem-statement" class="anchor" href="#problem-statement" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Problem Statement</h1>

<p>In this project, I set out to recreate the graphical effect made famous by the 2007 video game Portal, by Valve Corporation. In that game, the player is able to create two portals, one blue and one orange, and these portals are "linked." So, when a player looks through the blue portal, it is as if they are looking through it and out of the orange portal, and vice versa. The screenshot below shows the effect in action, and shows one interesting aspect of the effect - portals can be seen through recursively.</p>

<p><img src="https://lh3.googleusercontent.com/_pl13HiabQubl8GBOEAHADXf_rtthnvYNnjcE64wtOs2p8B1D52sLc7LCIBEwxws8WE7_kdxYoHQAYBRDpAdLJXKkUYf7LSg0dOVsGCd_Boc-Br7mQqxI0E5gb6nWRywsA7gnFhzE5ImCdCQDraksX40A3sUyDjQutnleLB_OLxeR9xVIypIK4lFDg2jgzGS6oyj7dwxufCBZL7z_fgI7uhO_5U63EEacZU8hDlewbOGfnkSga2k8HD92wZFB5CJnHYMO3eZuznT6xhdsAlE1HxnG1c9JtLLDv9uMpAte8Dp2m3rWkMcoJbjdgkT-OnaOR9Riw8o2iuF91llwKuQguMVE1dMpi_ZaAZFBQ7FfSWFqNoBH7dT_utSjhwGHEH2fZyu5tYMC-t-hN07tNB2iRzzUVQkKubICDwS9a_ddvToQkPJdMJrDq-k8NxnEPfRB-qbAl1KIiy1uBJNtA7bGvrYoRG6F_UqBGAe6U_U8pGJMEjArGnuzvDD0_1e5S_DlByTgSQ6W60pwnJ8dEZzCYYlPy3wpgIJOlE4BWcQKYj4gKGzJJKJlyFrmBlAuS5mNZHnL089Uv7GOxLXp919JTxk3NaY3aQ=w933-h525-no" alt=""></p>

<p>This diagram shows what's actually going on here: when looking into the blue portal, the viewer's line of sight goes towards the blue portal, comes out of the orange portal and into the blue portal at a different angle, and finally exits the orange portal at a different angle.</p>

<p><img src="https://lh3.googleusercontent.com/8lCbA2mIwcw67WRdiJT39R2_tG4WkXlxBkw3yrGr17-iu8Q0XXFKCcBUCqb7I5AeiKOqZqP9VzALQnkDR6sq-FYezWXSv8Vg6oMAkDl8pfxqEwOu1niIGXv9Q1nOXWyaRExojk1Oa9qxfdpgkWB_sOyJIvCHBmo6fROWaXw1JtZqyC3L4RJY0im9Engye7gb8suqyFsRhumRBllGrvmwbw-SPuCRj0konUYhVDpwLKP8dX0zeHv-48pp-3mB_NuSstRI4W0QdAY6reaEYPQDwIZr2mw1KLe_h0TxbrgDcaCttVwKOCd-IjGGDseETBXgOsi0apjRP_Nj9q7ayG4118SAx-XvdMFfNOQk_-lYDMEsoAf1Lz4c78bri8_ciYUBfv6s5L2J3MICuPqQm5XtQLZT3hKxRQqID45ZvVaA7EYKfDNBf5Cpcg8WLsNafjcSvZXOkCL2DcX14r6_lMyrecrbl9huKR3JUCPzkvEVOgEP-AZPn2zIBGc5M6J31K3ohhZNEfsBoG-vq-RydV_P5tfMnegtT3_0YlUnG_IFhwCftGXrAma5_dXBSO3aPvPH2BQyWliyW4WdHIjNbezdy0z964yRKMY=w481-h374-no" alt=""></p>

<p>As you might be able to imagine from the above description, this effect, like many things in graphics, would be quite easy to achieve using ray tracing - all one would have to do would be to properly generate the outgoing ray when a ray met a portal. However, since the inspiration for my project was a video game, I wanted to create this effect in real time, using rasterized graphics with OpenGL.</p>

<h1>
<a id="technical-description" class="anchor" href="#technical-description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Technical Description</h1>

<h2>
<a id="non-recursive-portal-rendering" class="anchor" href="#non-recursive-portal-rendering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Non-recursive portal rendering</h2>

<p>My basic approach to making this work was based on a comment made by one of my coworkers as I was discussing the project, and is based around the use of OpenGL's stencil buffer. The stencil buffer is similar to the depth buffer, in that the buffer does not appear on the screen, but is used to determine which future fragments will be discarded before being drawn to the screen. You can write to the stencil buffer in one draw call, and then on future draw calls it is possible to tell OpenGL to discard all fragments except those with a certain value in the stencil buffer. With this tool, I figured out a simple algorithm for rendering portals:</p>

<ol>
<li><p>Draw the normal scene without portals.</p></li>
<li><p>Draw the portals, writing a different value to the stencil buffer for each portal - e.g. 1 for portal one, 2 for portal two.</p></li>
<li>
<p>For each portal:</p>

<p>a. Position the camera facing out of the other portal.</p>

<p>b. Render the scene, with the stencil buffer condition set to only allow fragments corresponding to the this portal.</p>
</li>
</ol>

<p>Step 3a was by far the most difficult part of this algorithm to implement. The first problem was determining the proper angle for the view vector, as it depends both on the view vector coming into the first portal, and on the relationship between the orientations of the two portals. I did this by imagining that the second portal was placed back to back with the first, so that the view vector angle would be unmodified (as if the portals were simply a normal window). Then, I calculated what rotation would turn this imaginary second portal's orientation into the actual orientation, and applied this rotation to the incoming view vector.</p>

<p>The second problem was determining the proper position for the camera facing out of the other portal. Simply placing the camera at the out portal's coordinates doesn't work, since this means that objects seen through the portal stay the same size, even as the viewer moves further away from the input portal. I eventually managed to calculate the proper position by computing the vector from the viewer's position to the input portal, rotating it through the same transformation applied to the view vector, and then walking the camera back along this vector from the output portal's position. This results in a camera placed behind the output portal, standing in the same relation to it that the viewer stands to the input portal.</p>

<p>With the camera in the right place, all that remained was to avoid the problem of objects <em>behind</em> the output portal occluding the view through the portal, which I accomplished simply by setting the distance to the near plane in the projection matrix to be equal to the viewer's distance from the portal.</p>

<h2>
<a id="recursive-portal-rendering" class="anchor" href="#recursive-portal-rendering" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Recursive portal rendering</h2>

<p>Rendering portals recursively becomes a bit more complicated, especially in the managing of the stencil buffer. The idea I came up with (which is actually pretty sub-optimal: see the next section) was to use the value in the stencil buffer as a bitfield, indicating exactly where in the portal hierarchy each fragment was. We saw above that three values were needed for the non-recursive case (0, 1, and 2), so I allocated two bits of the stencil buffer to each layer of portals. Thus, b00000000 represents a fragment in the "real world", b00000001 a fragment seen through portal 1, and b00000010 a fragment seen through portal 2. Then, b00000101 represents a fragment inside portal 1 inside portal 1, b00100101 a fragment inside portal 2 inside portal 1 inside portal 1, and so forth. Thus, whenever I'm rendering a view through several recursive portals, I know exactly which stencil buffer value to condition on to render only to those pixels contained within the appropriate nested set of portals. Here's a screenshot of my program rendering a "hall of mirrors" effect using recursive portals:</p>

<p><img src="https://lh3.googleusercontent.com/PQb_pAxxDKZ0nYpcXOXfZc5lcduD4Pku8ojGY1dZHohER2onu5AA6NC5L3LUGpjsZDyhwaK1TiDKCmkvHnwWBt3aEznQBAOoQED7y7jWyHlnjF7_cEYzUhRddH1cEebuOIVd2JRDM9LxR8oP9dFng4cy-q--GwbBhEygO6rlqHe0A9BS3s3a9EwFmOU0Sykk3L16li9ZEH_hqFhlfgcd2jjj_CKb8xHYsTH7n1PFeRGdBaQ_CLJvUQ5pLZh80ymwX-HhI_hzWL7NZdazxhljCy5rCN9lmgLkAi-UeOPu8t4DDvVBzigrRZM8oy466QEvmHVU5Xax6AzOHcZ_lWyTO10GZNg254aleceaYUo2vopKLIAlPq0tTL9sQ1AykV_3wCJbHXuz1LDbvnID1VWsknM-UlLkQpCY1ulylprEWRdauBFMGmpS2LOiXG8mUi6tOiq6YF-VO1ZXX5IS2E3RlV7Z9JY1YZRJTeqzetqTjqL7KuR2I-axt-etFoxf19qyRG-n3Sob_j1lbGyJb7FQx2-PdVYed2RWXfyPaeckzWQAGvSrJ4NrERUnZ7HjWdCA9dxWwYpIxJ70y-d7HdkJ-n1LMPje2tw=w933-h525-no" alt=""></p>

<p>This approach works, and it is what is shown in my demo video and the code on GitHub. However, an obvious limitation of this approach is that it limits the depth of portal rendering - with an eight bit stencil buffer, only four levels of portals are possible. Noticing that we only need three distinct values and packing even tighter using base three gives us one more level, since 3^5 = 243 &lt; 256, but this would be annoying to implement.</p>

<p>A better improvement is based on something I realized only after I implemented recursive rendering. In the absence of more than two portals, or any other reflective surfaces, it's easy to see that when you're looking through a given portal, the only portal you'll ever see inside of it is the same portal. So if you look through portal 1, your view ray comes out of portal 2, meaning that it is impossible for you to actually see portal 2. Thus, for any level after the first, only one bit is needed to represent the state of the pixel, meaning that a total of seven levels could be shown using an eight bit field.</p>

<h2>
<a id="comparison-to-other-approaches" class="anchor" href="#comparison-to-other-approaches" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comparison to other approaches</h2>

<p>While I did look for some prior art on rendering portals before starting my project, I intentionally didn't look at how these sources implemented portals until after I had implemented my approach, as I thought it would be interesting to compare and contrast what I came up with with what others had implemented.</p>

<h3>
<a id="thomas-rinsmas-portal-rendering-approach" class="anchor" href="#thomas-rinsmas-portal-rendering-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Thomas Rinsma's portal rendering approach</h3>

<p>My first source was <a href="https://th0mas.nl/2013/05/19/rendering-recursive-portals-with-opengl/">a blog post by Thomas Rinsma</a> about rendering recursive portals in OpenGL. Thomas's approach is similar to mine, but different (and superior) in an important detail: in his approach, he renders portals in a <em>depth first</em> manner, where the first portal is rendered and the complete view through it drawn before the second portal is rendered. This has the crucial benefit that it means he doesn't have to record different values to the stencil buffer for the different portals, since only one portal is being rendered at a time. So, the only thing he has to store in the stencil buffer is an integer representing how deep in the current portal stack that fragment is. Thus, his approach supports up to 255 levels of portals with an eight bit stencil buffer.</p>

<p>One very clever aspect of his approach is how he handles restoring the stencil buffer when backtracking to a higher level after rendering a (nested) portal. In my approach, I reserved a bit (or two) for each level so that this could be done with a bitmask. Thomas's approach instead <em>increments</em> the stencil buffer when the portal is drawn for the first time, and then when backtracking draws the same portal again, but <em>decrementing</em> the stencil buffer instead, thus restoring it to its previous state.</p>

<h3>
<a id="narbacular-drops-portal-rendering-approach" class="anchor" href="#narbacular-drops-portal-rendering-approach" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Narbacular Drop's portal rendering approach</h3>

<p>While I'm not sure exactly which approach the real game Portal used, I can make an educated guess based on the spiritual predecessor to Portal, Narbacular Drop. Narbacular Drop was a student project at Digipen with nearly identical mechanics to Portal, and the students responsible were hired by Valve to make Portal. Fortunately, Narbacular Drop's <a href="https://www.digipen.edu/fileadmin/website_data/gallery/game_websites/NarbacularDrop/">original technical design document</a> is available online, which describes how they achieved the effect. Interestingly, they did not use the stencil buffer at all. Instead, they rendered the view from the output portal onto a texture, which was then applied to wherever the input portal was placed. This has some interesting advantages over my approach - for example, there's no need to place the portal camera behind the output portal to draw things at the proper scale, since the texture itself will automatically appear smaller when the viewer is further from the portal. It would be interesting to implement this approach and compare its performance and complexity to the stencil buffer approach.</p>

<h1>
<a id="sources" class="anchor" href="#sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sources</h1>

<p>Inspired by the game Portal (2007), by Valve Corporation.</p>

<p>Starter code was based off of the example code from <a href="http://www.learnopengl.com">www.learnopengl.com</a>, by Joey de Vries.</p>

<p>Thomas Rinsma’s blog post on rendering recursive portals was an inspiration and point of comparison: <a href="https://th0mas.nl/2013/05/19/rendering-recursive-portals-with-opengl/">https://th0mas.nl/2013/05/19/rendering-recursive-portals-with-opengl/</a></p>

<p>The technical design document for Narbacular Drop was used as a point of comparison: <a href="https://www.digipen.edu/fileadmin/website_data/gallery/game_websites/NarbacularDrop/">https://www.digipen.edu/fileadmin/website_data/gallery/game_websites/NarbacularDrop/</a></p>

<p>The 3D model used in the demo is “Dust Level” by eCstatic on TurboSquid, itself based on a popular Counter-Strike level.: <a href="http://www.turbosquid.com/3d-models/free-blend-model-dust-level/631230">http://www.turbosquid.com/3d-models/free-blend-model-dust-level/631230</a> </p>
      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
