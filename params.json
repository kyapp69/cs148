{
  "name": "Rendering \"Portal\"",
  "tagline": "CS 148 Final Project",
  "body": "You can see a video version of this report with a live demo [here!](https://www.youtube.com/watch?v=C2PqlxjEwy4) Also, click View On GitHub above to see my source code.\r\n\r\n# Problem Statement\r\nIn this project, I set out to recreate the graphical effect made famous by the 2007 video game Portal, by Valve Corporation. In that game, the player is able to create two portals, one blue and one orange, and these portals are \"linked.\" So, when a player looks through the blue portal, it is as if they are looking through it and out of the orange portal, and vice versa. The screenshot below shows the effect in action, and shows one interesting aspect of the effect - portals can be seen through recursively.\r\n\r\n![](https://lh3.googleusercontent.com/_pl13HiabQubl8GBOEAHADXf_rtthnvYNnjcE64wtOs2p8B1D52sLc7LCIBEwxws8WE7_kdxYoHQAYBRDpAdLJXKkUYf7LSg0dOVsGCd_Boc-Br7mQqxI0E5gb6nWRywsA7gnFhzE5ImCdCQDraksX40A3sUyDjQutnleLB_OLxeR9xVIypIK4lFDg2jgzGS6oyj7dwxufCBZL7z_fgI7uhO_5U63EEacZU8hDlewbOGfnkSga2k8HD92wZFB5CJnHYMO3eZuznT6xhdsAlE1HxnG1c9JtLLDv9uMpAte8Dp2m3rWkMcoJbjdgkT-OnaOR9Riw8o2iuF91llwKuQguMVE1dMpi_ZaAZFBQ7FfSWFqNoBH7dT_utSjhwGHEH2fZyu5tYMC-t-hN07tNB2iRzzUVQkKubICDwS9a_ddvToQkPJdMJrDq-k8NxnEPfRB-qbAl1KIiy1uBJNtA7bGvrYoRG6F_UqBGAe6U_U8pGJMEjArGnuzvDD0_1e5S_DlByTgSQ6W60pwnJ8dEZzCYYlPy3wpgIJOlE4BWcQKYj4gKGzJJKJlyFrmBlAuS5mNZHnL089Uv7GOxLXp919JTxk3NaY3aQ=w933-h525-no)\r\n\r\nThis diagram shows what's actually going on here: when looking into the blue portal, the viewer's line of sight goes towards the blue portal, comes out of the orange portal and into the blue portal at a different angle, and finally exits the orange portal at a different angle.\r\n\r\n![](https://lh3.googleusercontent.com/8lCbA2mIwcw67WRdiJT39R2_tG4WkXlxBkw3yrGr17-iu8Q0XXFKCcBUCqb7I5AeiKOqZqP9VzALQnkDR6sq-FYezWXSv8Vg6oMAkDl8pfxqEwOu1niIGXv9Q1nOXWyaRExojk1Oa9qxfdpgkWB_sOyJIvCHBmo6fROWaXw1JtZqyC3L4RJY0im9Engye7gb8suqyFsRhumRBllGrvmwbw-SPuCRj0konUYhVDpwLKP8dX0zeHv-48pp-3mB_NuSstRI4W0QdAY6reaEYPQDwIZr2mw1KLe_h0TxbrgDcaCttVwKOCd-IjGGDseETBXgOsi0apjRP_Nj9q7ayG4118SAx-XvdMFfNOQk_-lYDMEsoAf1Lz4c78bri8_ciYUBfv6s5L2J3MICuPqQm5XtQLZT3hKxRQqID45ZvVaA7EYKfDNBf5Cpcg8WLsNafjcSvZXOkCL2DcX14r6_lMyrecrbl9huKR3JUCPzkvEVOgEP-AZPn2zIBGc5M6J31K3ohhZNEfsBoG-vq-RydV_P5tfMnegtT3_0YlUnG_IFhwCftGXrAma5_dXBSO3aPvPH2BQyWliyW4WdHIjNbezdy0z964yRKMY=w481-h374-no)\r\n\r\nAs you might be able to imagine from the above description, this effect, like many things in graphics, would be quite easy to achieve using ray tracing - all one would have to do would be to properly generate the outgoing ray when a ray met a portal. However, since the inspiration for my project was a video game, I wanted to create this effect in real time, using rasterized graphics with OpenGL.\r\n\r\n# Technical Description\r\n\r\n## Non-recursive portal rendering\r\n\r\nMy basic approach to making this work was based on a comment made by one of my coworkers as I was discussing the project, and is based around the use of OpenGL's stencil buffer. The stencil buffer is similar to the depth buffer, in that the buffer does not appear on the screen, but is used to determine which future fragments will be discarded before being drawn to the screen. You can write to the stencil buffer in one draw call, and then on future draw calls it is possible to tell OpenGL to discard all fragments except those with a certain value in the stencil buffer. With this tool, I figured out a simple algorithm for rendering portals:\r\n\r\n1) Draw the normal scene without portals.\r\n2) Draw the portals, writing a different value to the stencil buffer for each portal - e.g. 1 for portal one, 2 for portal two.\r\n3) For each portal:\r\n  a) Position the camera facing out of the other portal.\r\n  b) Render the scene, with the stencil buffer condition set to only allow fragments corresponding to the this portal.\r\n\r\nStep 3a was by far the most difficult part of this algorithm to implement. The first problem was determining the proper angle for the view vector, as it depends both on the view vector coming into the first portal, and on the relationship between the orientations of the two portals. I did this by imagining that the second portal was placed back to back with the first, so that the view vector angle would be unmodified (as if the portals were simply a normal window). Then, I calculated what rotation would turn this imaginary second portal's orientation into the actual orientation, and applied this rotation to the incoming view vector.\r\n\r\nThe second problem was determining the proper position for the camera facing out of the other portal. Simply placing the camera at the out portal's coordinates doesn't work, since this means that objects seen through the portal stay the same size, even as the viewer moves further away from the input portal. I eventually managed to calculate the proper position by computing the vector from the viewer's position to the input portal, rotating it through the same transformation applied to the view vector, and then walking the camera back along this vector from the output portal's position. This results in a camera placed behind the output portal, standing in the same relation to it that the viewer stands to the input portal.\r\n\r\nWith the camera in the right place, all that remained was to avoid the problem of objects *behind* the output portal occluding the view through the portal, which I accomplished simply by setting the distance to the near plane in the projection matrix to be equal to the viewer's distance from the portal.\r\n\r\n## Recursive portal rendering\r\n\r\nRendering portals recursively becomes a bit more complicated, especially in the managing of the stencil buffer. The idea I came up with (which is actually pretty sub-optimal: see the next section) was to use the value in the stencil buffer as a bitfield, indicating exactly where in the portal hierarchy each fragment was. We saw above that three values were needed for the non-recursive case (0, 1, and 2), so I allocated two bits of the stencil buffer to each layer of portals. Thus, b00000000 represents a fragment in the \"real world\", b00000001 a fragment seen through portal 1, and b00000010 a fragment seen through portal 2. Then, b00000101 represents a fragment inside portal 1 inside portal 1, b00100101 a fragment inside portal 2 inside portal 1 inside portal 1, and so forth. Thus, whenever I'm rendering a view through several recursive portals, I know exactly which stencil buffer value to condition on to render only to those pixels contained within the appropriate nested set of portals.\r\n\r\nThis approach works, and it is what is shown in my demo video and the code on GitHub. However, an obvious limitation of this approach is that it limits the depth of portal rendering - with an eight bit stencil buffer, only four levels of portals are possible. Noticing that we only need three distinct values and packing even tighter using base three gives us one more level, since 3^5 = 243 < 256, but this would be annoying to implement.\r\n\r\nA better improvement is based on something I realized only after I implemented recursive rendering. In the absence of more than two portals, or any other reflective surfaces, it's easy to see that when you're looking through a given portal, the only portal you'll ever see inside of it is the same portal. So if you look through portal 1, your view ray comes out of portal 2, meaning that it is impossible for you to actually see portal 2. Thus, for any level after the first, only one bit is needed to represent the state of the pixel, meaning that a total of seven levels could be shown using an eight bit field.\r\n\r\n## Comparison to other approaches",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}